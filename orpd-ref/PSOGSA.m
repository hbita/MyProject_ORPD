%PSOGSA source code v3.0, Generated by SeyedAli Mirjalili, 2011. 
%Adopted from: S. Mirjalili, S.Z. Mohd Hashim, “A New Hybrid PSOGSA 
%Algorithm for Function Optimization, in IEEE International Conference 
%on Computer and Information Application?ICCIA 2010), China, 2010, pp. 374-377.


                              %-------------------------------------------%
                              %         Evaluate the population           %           
                              %-------------------------------------------%                                 %--%
 %%% Variables %%%

%current_position:  Position of particles
%velocity:          Velocity
%force:             The gravitational force between the particles
%acceleration:      Acceleration
%mass:              Mass 
%dim:               Dimension of test functions
%n:                 Number of particles
%G0                 Gravitational constant
%low:               The lower bound of the search space
%up:                The higher bound of the search space

%[Fbest,Lbest,BestChart]=GSA(N,max_it,testsistem,Case)

function [Fbest,Lbest,BestChart]=PSOGSA(N,max_it,testsistem,Case)
%--------------------------------------------------------------------------
%Parametri PSOGSA
G0=1;                                        % gravitational constant                                         
alfa=20;
C1=2; 
C2=2;
%C1=0.5; %C1 in Equation (9)
%C2=1.5; %C2 in Equation (9)
%--------------------------------------------------------------------------
%[low,up,dim]=benchmark_functions_details(Benchmark_Function_ID);%define the boundary and dimension of the benchmark function
[low,up,dim]=ogranicenja(testsistem); low=low';up=up';
current_fitness =zeros(N,1);
Lbest=zeros(1,dim);
Fbest=inf;

for i=1:N
        pBestScore(i)=inf;
end
        pBest=zeros(N,dim);

Boundary_no = size(up',2);

if Boundary_no==1
    current_position = rand(N,dim).*(up-low)+low; %initial positions in the problem's boundary
end

% If each variable has a different up and low
if Boundary_no>1
    for i=1:dim
        up_i=up(i,1);
        low_i=low(i,1);
       current_position(:,i)=rand(N,1).*(up_i-low_i)+low_i; %initial positions in the problem's boundary
    end
end


%velocity = .3*randn(n,dim) ;
velocity = randn(N,dim) ;  %?????????????????????????????
acceleration=zeros(N,dim);
mass(N)=0;
force=zeros(N,dim);



%%main loop
iter = 0 ;                  % Iterations’ counter
while  ( iter < max_it )

%G=G0*exp(-23*iter/iteration); %Equation (4)
G=G0*exp(-alfa*iter/max_it); %Equation (4)
%G=G0*exp(-10*iter/iteration); %Equation (4)
iter = iter + 1;
iter;
force=zeros(N,dim);
mass(N)=0;
acceleration=zeros(N,dim);

for i = 1:N
    fitness=0;
    %///Bound the search Space///
    %Tp=current_position(i,:)>up;Tm=current_position(i,:)<low;current_position(i,:)=(current_position(i,:).*(~(Tp+Tm)))+up.*Tp+low.*Tm;                     
    
    Flag4up=current_position(i,:)>up';
    Flag4low=current_position(i,:)<low';
    current_position(i,:)=(current_position(i,:).*(~(Flag4up+Flag4low)))+up'.*Flag4up+low'.*Flag4low; 
    %////////////////////////////
    
                                 %-------------------------------------------%
                                 %         Evaluate the population           %           
                                 %-------------------------------------------%      
    %fitness=benchmark_functions(current_position(i,:),testsistem,dim);
    fitness=Fobj(current_position(i,:),testsistem,Case);

    current_fitness(i)=fitness;    
        
    if(pBestScore(i)>fitness)
        pBestScore(i)=fitness;
        pBest(i,:)=current_fitness(i,:);
    end
    if(Fbest>fitness)
        Fbest=fitness;
        Lbest=current_position(i,:);
    end
    
end

best=min(current_fitness);
worst=max(current_fitness);

        BestChart(iter)=Fbest;
        BestChart(iter);
        best;

    for pp=1:N
        if current_fitness(pp)==best
            break;
        end
        
    end
    
    bestIndex=pp;
            
    for pp=1:dim
        best_fit_position(iter,1)=best;
        best_fit_position(iter,pp+1)=current_position(bestIndex,pp);   
    end


                                               %-------------------%
                                               %   Calculate Mass  %
                                               %-------------------%
    for i=1:N
    %mass(i)=(current_fitness(i)-0.99*worst)/(best-worst); 
    mass(i)=(current_fitness(i)-worst)/(best-worst); %?????????????????????
end

for i=1:N
    %mass(i)=mass(i)*5/sum(mass);    
    mass(i)=mass(i)/sum(mass);              %?????????????????????
end

                                               %-------------------%
                                               %  Force    update  %
                                               %-------------------%

for i=1:N
    for j=1:dim
        for k=1:N
            if(current_position(k,j)~=current_position(i,j))
                % Equation (3)
                force(i,j)=force(i,j)+ rand()*G*mass(k)*mass(i)*(current_position(k,j)-current_position(i,j))/abs(current_position(k,j)-current_position(i,j));
                
            end
        end
    end
end
                                               %------------------------------------%
                                               %  Accelations $ Velocities  UPDATE  %
                                               %------------------------------------%

for i=1:N
       for j=1:dim
            if(mass(i)~=0)
                %Equation (6)
                acceleration(i,j)=force(i,j)/mass(i);
            end
       end
end   
%wvel=linspace(0.9,0.4,iteration);  %?????????????????????
wvel(iter)=((max_it - iter)*(0.9 - 0.4))/(max_it-1) + 0.4;
for i=1:N
        for j=1:dim
            %Equation(9)
            velocity(i,j)=rand()*velocity(i,j)+C1*rand()*acceleration(i,j) + C2*rand()*(Lbest(j)-current_position(i,j));
            %velocity(i,j)=wvel(iter)*velocity(i,j)+C1*rand()*acceleration(i,j) + C2*rand()*(gBest(j)-current_position(i,j));  %?????????????????????
        end
end
                                               %--------------------------%
                                               %   positions   UPDATE     %
                                               %--------------------------%
                                                        
%Equation (10) 
current_position = current_position + velocity ;
 
end
end


